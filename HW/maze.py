import os
import time

class MazeRunner:
    def __init__(self):
        # กำหนดเขาวงกตในรูปแบบ list-of-lists
        # แต่ละตำแหน่งในเขาวงกตจะมีค่าเป็นสตริง
        # "X" = กำแพง, " " = ทางเดินว่าง, "S" = จุดเริ่มต้น, "E" = จุดสิ้นสุด
        self.maze = [
            ["X", "X", "X", "X", "X", "X", "X", "X", "X", "X", "X", "X", "X"],
            ["X", " ", " ", " ", "X", " ", "X", " ", "X", " ", "X", " ", "X"],
            ["X", " ", "X", " ", " ", " ", "X", " ", "X", "X", "X", " ", "X"],
            ["X", " ", "X", " ", "X", " ", "X", " ", "X", "X", "X", " ", "X"],
            ["X", " ", "X", " ", "X", " ", " ", " ", " ", " ", "X", " ", "X"],
            ["X", " ", " ", " ", "X", " ", "X", " ", "X", "X", "X", " ", "X"],
            ["E", " ", "X", " ", "X", " ", "X", "X", "X", " ", "X", " ", "X"],
            ["X", "X", "X", " ", "X", " ", " ", " ", "X", " ", " ", " ", "X"],
            ["X", " ", "X", " ", "X", " ", "X", " ", "X", " ", "X", " ", "X"],
            ["X", " ", "X", " ", " ", " ", "X", " ", "X", " ", "X", " ", "X"],
            ["X", " ", "X", "X", "X", "X", "X", " ", "X", " ", "X", " ", "X"],
            ["X", " ", "X", " ", "X", " ", "X", " ", "X", " ", "X", " ", "X"],
            ["X", " ", " ", " ", " ", " ", " ", " ", " ", " ", "X", " ", "X"],
            ["X", " ", "X", "X", " ", "X", "X", " ", "X", " ", "X", " ", "X"],
            ["X", "S", "X", "X", "X", "X", "X", "X", "X", "X", "X", "X", "X"],
        ]
        # กำหนดจำนวนแถวและคอลัมน์ของเขาวงกต
        self.rows = len(self.maze)
        self.cols = len(self.maze[0]) if self.rows > 0 else 0

        # ค้นหาตำแหน่งของจุดเริ่มต้น ('S') และจุดสิ้นสุด ('E')
        self.start = self.find_marker('S')
        self.exit = self.find_marker('E')

    def find_marker(self, marker):
        """
        ค้นหาตำแหน่งของ marker ที่ระบุ (เช่น 'S' หรือ 'E')
        คืนค่าเป็น tuple (row, col) หากพบ ไม่เช่นนั้นคืนค่า None
        """
        for r in range(self.rows):
            for c in range(self.cols):
                if self.maze[r][c] == marker:
                    return (r, c)
        return None

    def show_maze(self):
        """
        ล้างหน้าจอและแสดงเขาวงกตในแต่ละขั้นตอน
        เพื่อให้เห็นการเปลี่ยนแปลงระหว่างการทำงานของ DFS (step-by-step)
        """
        # ล้างหน้าจอ: ใช้ 'cls' สำหรับ Windows และ 'clear' สำหรับ Unix/Linux/MacOS
        os.system('cls' if os.name == 'nt' else 'clear')
        # วนลูปแสดงแต่ละแถวของเขาวงกต โดยคั่นด้วยช่องว่าง
        for row in self.maze:
            print(" ".join(row))
        # หน่วงเวลาเล็กน้อย (0.1 วินาที) เพื่อให้เห็นการเปลี่ยนแปลงของขั้นตอน
        time.sleep(0.1)

    def dfs(self, r, c):
        """
        ค้นหาเส้นทางออกจากเขาวงกตโดยใช้ Depth-First Search (DFS)
        รับพิกัดปัจจุบัน (r, c) และคืนค่า True หากพบทางออก,
        หากไม่พบหรือหมดเส้นทางให้คืนค่า False
        """
        # ตรวจสอบว่าพิกัดอยู่นอกขอบเขตของเขาวงกตหรือไม่
        if r < 0 or r >= self.rows or c < 0 or c >= self.cols:
            return False

        # หากตำแหน่งนี้เป็นกำแพง ("X") หรือเคยผ่านแล้ว (เครื่องหมาย '.' ถูกใช้เป็น marker),
        # ให้ข้ามการค้นหาจากตำแหน่งนี้
        if self.maze[r][c] in ('X', '.'):
            return False

        # หากพิกัดปัจจุบันคือจุดสิ้นสุด ให้แสดงเขาวงกตแล้วแสดงข้อความสำเร็จ
        if (r, c) == self.exit:
            self.show_maze()  # แสดงสถานะปัจจุบันของเขาวงกต
            print(">>>>> ยินดีด้วย! พบทางออกแล้ว! <<<<<")
            return True

        # ทำเครื่องหมายตำแหน่งปัจจุบันเป็นเครื่องหมายว่า "ผ่านแล้ว"
        # โดยเว้นไว้หากเป็นจุดเริ่มต้น ('S') เพื่อไม่ให้เปลี่ยนแปลงค่า
        if self.maze[r][c] != 'S':
            self.maze[r][c] = '.'
        self.show_maze()

        # สำรวจใน 4 ทิศทาง: ขวา, ล่าง, ซ้าย, ขึ้น
        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            if self.dfs(r + dr, c + dc):
                # หากพบทางออกในทิศใด ให้คืนค่า True ทันที
                return True

        # หากไม่มีทางออกจากตำแหน่งนี้ (dead end)
        # ทำการย้อนกลับ (backtracking) โดยลบเครื่องหมายที่ทำไว้คืนเป็นช่องว่าง
        if self.maze[r][c] != 'S':
            self.maze[r][c] = ' '
        self.show_maze()
        return False

def main():
    # สร้างอินสแตนซ์ของ MazeRunner
    solver = MazeRunner()
    # แสดงเขาวงกตเริ่มต้น
    solver.show_maze()
    
    # ตรวจสอบว่ามีการค้นหาจุดเริ่มต้น ('S') ในเขาวงกตหรือไม่
    if solver.start is None:
        print("ไม่พบจุดเริ่มต้น ('S') ในเขาวงกต!")
        return

    # เริ่มต้นค้นหาเส้นทางจากจุดเริ่มต้น
    if not solver.dfs(*solver.start):
        print("ไม่พบทางออกในเขาวงกตนี้!")

# เรียกใช้งานฟังก์ชัน main() เมื่อรันสคริปต์นี้
if __name__ == '__main__':
    main()
